## 목차

### OT

#### C언어란 무엇인가

* C언어가 왜 어렵나
- C언어의 문법 자체는 48년 전과 별반 차이가 없음
- 그러나 컴퓨터의 기능, 용량이 천지차이

* 왜 배워야 하는가
- 한 번 제대로 배워놓으면 오래 써먹을 수 있음
- C언어에 기반으로 하는 언어들이 많음
- 추상화의 정도가 작음 (자동차 수동 운전) - 해야 할 것이 많은 반면 여러 가지를 제어 가능

- 컴퓨터의 작동 원리를 잘 아면 C언어를 이해하기 쉬움 -> 컴퓨터의 작동 원리에 대한 이해가 필요

---

#### 컴퓨터란 무엇인가

* 일련의 연산을 수행하는 계산기
* 명령어를 읽어들여서 주어진 명령어에 따라 연산

1. 누가 명령어를 읽는가?
2. 어디서 명령어를 읽는가?
3. 프로그램이란게 뭐지?
4. 명령어는 어떻게 작성하는가?

---

#### 누가 명령어를 읽는가

* 컴퓨터의 모든 연산은 중앙 처리 장치, CPU (Central Processing Unit) 이라 불리는 작은 반도체에 의해서 처리.

* CPU 는 1초에 약 10억번 개의 연산을 처리, 엄청난 양의 열을 발생. 쿨러가 바로 CPU를 식혀주는 역할을 함.

* 최근에는 그래픽 관련 연산을 전문적으로 처리하는 GPU라는 장치가 있으나 CPU처럼 다양한 종류의 명령어 처리는 불가. 범용적인 명령어는 전부 CPU 관할

---

#### 어디서 명령어를 읽는가

* 명령어를 실행
1. 실행할 명령어를 읽어야 함
2. 연산된 결과를 저장해야 함

* CPU에 명령어와 연산한 결과를 저장하기에는 연산에 특화된 장치기에 공간이 매우 부족

##### 레지스터

* CPU가 연산을 수행하기 위해 데이터를 저장하는 공간을 레지스터(register)라고 부름. 64비트 CPU기준으로 16개, 각 레지스터는 64비트의 데이터 저장 가능. CPU에 저장할 수 있는 데이터는 최대 128바이트.

* 기술 한계상 레지스터의 개수를 늘릴 수는 없기에 CPU 밖 저장공간이 필요함.

##### 램

* CPU 바로 옆에서 저장 공간 역할을 하는 장치가 바로 램(RAM, Random Access Memory, 임의 접근 메모리)

* CPU의 레지스터(128바이트)보다 6천만 배 큰 용량, CPU는 램에 실행할 명령어나 데이터들을 저장하고 있다 연산을 수행할 때 명령을 램에서 읽어들임.

##### HDD, SSD

* 램은 전기가 있을 경우에만 유지되는 휘발성 메모리. 전원이 끊기면 메모리의 데이터는 모두 날아간다.

* 컴퓨터가 꺼져도 데이터를 유지할 수 있는 저장장치, 하드 디스크과 SSD가 등장. 데이터를 읽어들이는 작업은 램에서보다 훨씬 느리지만 전기 공급 없이도 데이터를 안정적으로 보관 가능.

##### 데이터가 이동하는 구조

* 램 -> CPU : 100 나노초
* SSD -> CPU : 5000 ~ 15000 나노초 | 50 ~ 150 마이크로초
* 하드디스크 -> CPU : 1000000 ~ 10000000 나노초 | 1 ~ 10 밀리초
* 평균 0.3 나노초마다 1번 연산을 하는 CPU, 하드 디스크에서 CPU에 데이터가 올 때까지 기다리는 동안 3천만 번의 연산을 수행할 수 있음.

* 컴퓨터 프로그램을 실행
    1. 하드 디스크에 저장되어 있는 프로그램의 위치를 찾아서 램에 복사
    2. CPU는 램에서 명령어를 읽어들여서 실행
        - CPU <-> RAM <-> HDD(하드 디스크) or SSD

##### 캐시

* CPU에서 RAM에 접근하는 속도도 꽤나 길기에 CPU는 빠르게 데이터를 레지스터에 불러올 수 있는 저장 공간으로 캐시(Cache)라는 것을 사용

* 캐시는 계층별로 L1, L2, L3 캐시로 이루어져 있음, L1 캐시의 경우 크기가 제일 작지만 (256KB) 레지스터와 가장 인접한 캐시, 1 나노초 만에 L1 캐시에 저장되어 있는 데이터를 읽을 수 있음. L3 캐시는 28 나노초가 걸리지만 크기가 제일 큼(~16MB)

* 지금 가장 필요한 데이터는 L1 캐시, 필요성이 낮으면 낮을 수록 L2, L3 캐시에 배치.

* 조만간 사용할 것 같은 데이터를 미리 캐시에 불러오거나, 램에 저장하기 직전 임시 보관하는 용도로도 쓰임. 

* 어떤 데이터가 미리 쓰일지 알 수 없기에 CPU는 여러가지 예측 알고리즘을 사용해서 캐시의 적중률을 높이려 함. 램의 전체 데이터를 중구 난방으로 사용하는 것 보다는 특정 부분만 반복적으로 접근하는 경우에 캐시 적중률이 높아짐.

*  CPU가 요청한 데이터가 캐시에 없을 수도 있음. 캐시 미스(Cache miss)시 램에서 필요한 데이터를 불러 오느라 상당히 시간이 지체됨.

#### 명령어는 어떻게 작성하는가?

* CPU 가 램에서 데이터를 읽어들이기 위해서는 램의 어디 에서 데이터를 읽어들일지 알아야 함. 램에 있는 모든 데이터는 1 바이트 단위로 0 번을 시작으로 고유의 주소(address) 가 부여되어 있음.

* 램은 크기가 1 바이트 (2진수로 8 자리수)짜리 데이터를 보관할 수 있는 수 많은 방들로 구성되어 있음. CPU가 램에게 어디에서 데이터를 읽을지 알려주면 램은 해당 위치에 있는 데이터를 즉각 전달. 어디에다 데이터를 저장할지 알려준다면 램은 해당 위치에 있는 데이터를 CPU 가 전달한 데이터로 저장 (덮어쓰기)

* 램 상에서는 데이터의 경계가 없기에 해당 주소값으로 부터 얼마 만큼 읽어야 할지도 지정해야 함. 얼마 만큼 읽어야 할 지는 명령어 단계에서 지정.

* CPU 에게 주소값 0x1234 에 1 바이트 만큼 3 이라는 데이터를 저장하려 함.
    1. CPU 의 레지스터에 접근하고자 하는 주소값 0x1234 를 저장. 편의상 a 라는 레지스터에 저장.
    2. a 에 저장된 주소값에서 부터 1 바이트 부분 까지 3 을 저장하라고 명령.
        - 이와 같이 CPU 가 직접적으로 해석하는 명령어를 어셈블리(Assembly) 라고 함. CPU 는 0 과 1 로 된 전기 신호만을 받아서 해석하지 알파벳 그대로 명령어를 받지 않음. 다만 어셈블리 명령어와 실제 CPU 가 읽어들이는 데이터와 1 대 1 대응이 되어 있기 때문에 (사람이 그나마 읽기 편하도록) 영어 명령어로 바꿔서 표현.
        - 메모리의 주소값에 해당하는 데이터를 접근하기 위해선, 먼저 그 주소값을 레지스터에 집어 넣고 해당 레지스터를 참조해야 함.

`* 64 비트 시스템 CPU 의 레지스터의 크기는 8 바이트. 레지스터에는 주소값을 전달할 수 있어야 하는데, 64 비트 시스템에서 주소값은 8 바이트 이기에 레지스터도 8 바이트가 되는 것.`

`* 8 바이트로는 2^{64} (= 18,446,744,073,709,551,616)2 64 (=18,446,744,073,709,551,616) 개의 수를 표현할 수 있지만엄청나게 큰 수를 표현하기에는 무리가 있음. CPU로 매우 큰 정수의 연산을 다루기 위해서는 수를 8 바이트 단위로 쪼개서 따로따로 연산을 해야겠지요.`

#### CPU 가 명령어를 읽어들이는 방법

* CPU 는 주소값 을 통해서 램에 어디에 접근할지 명령

* CPU 가 독자적으로 명령을 내릴 수 없기에 해당 명령어를 어디선가 가져와야 합니다. 이와 같이 CPU에 실행할 명령어를 제공하는 것을, 쉬운 말로 [프로그램을 실행한다] 라고 함.

* 프로그램은 실행할 명령어와 데이터들의 집합. 프로그램을 실행하게 되면 컴퓨터의 운영체제가 CPU에게 램에 위치해 있는 프로그램의 시작점을 알려주고 그 이후 CPU는 해당 위치 부터 명령어를 읽어나가며 실행.

* 중요한 것은 CPU가 현재 램의 어디에서 명령어를 읽어야 할지 계속 알아야 한다는 것. 이는 CPU 안에 지금 읽어들일 명령어의 위치 (instruction pointer) 만을 보관하는 특별한 레지스터 덕분에 가능. (인텔 64 비트 CPU 의 경우 해당 레지스터의 이름은 RIP) 명령어를 처리한 이후 RIP는 다음 명령어를 가리키는 주소값으로 자동으로 업데이트 됨.

* CPU 는 현재 내가 어떠한 프로그램을 실행하고 있는지 모름. 그저 현재 자신의 RIP 레지스터가 가리키는 위치에 있는 명령어를 실행하고 그 다음 명령어의 위치로 RIP를 증가시킬 뿐 어떠한 프로그램에서 해당 명령어를 실행하는지 모름.

* 스타크래프트를 실행했다 가정. 하드 디스크나 SSD 같은 저장 장치에 있는 스타크래프트 프로그램 파일을 메모리에 복사하는 작업을 운영체제 단에서 해결

* 메모리에는 데이터와 프로그램 명령어를 구분해서 저장하지 않기에 CPU의 관점에서는 메모리의 특정 주소값을 읽을 때 둘을 구별할 수 없음. 운영체제가 알려준 처음으로 실행할 명령어의 위치부터 명령어를 단순하게 쭉 읽어나갈 뿐. 이를 악용한 해킹 기법도 있음.

#### 가상 메모리, 물리 메모리

* 실제 RAM에서는 여러가지 프로그램들이 램의 여러 부분을 나누어서 차지해 실행되고 있을 것.

* 만일 어셈블리 명령어로 램 메모리의 0x1234 (십진수로 4660) 에 위치해 있는 곳에서 4 바이트 만큼의 공간에 3 이라는 값을 쓰라는 명령했다 가정. 그러나 그 시점에 해당 공간에서 프로그램이 실행되고 있다면 데이터를 손상시키게 될 것. 그렇기에 CPU에서 메모리를 조금 더 효율적으로 관리하기 위해 특별한 메커니즘을 제공.

* CPU가 0x1234 에 3 이라는 데이터를 쓰라는 명령을 내리면 메모리의 주소값 0x1234 의 위치에 3을 쓰게된다고 하는 것은 거짓. 이렇게 된다면 앞서 이야기 했던 문제를 해결할 수 없기 때문.

* 실제로 CPU가 보는 0x1234 라는 주소값과 실제 메모리의 0x1234 주소값은 차이가 있음. CPU가 참조하는 0x1234 라는 주소값은 특별한 1 대 1 변환 과정에 의해서 실제 메모리의 주소값을 변환. 이렇게 변환된 주소는 0x1234 가 될 수 도 있고 아니면 아예 0x12345678 처럼 전혀 다른 곳에 있는 메모리 주소값이 될 수 도 있음.

* CPU 가 참조하는 메모리 주소값을 가상 메모리(virtual memory), 일련의 변환 과정에 의해 참조하게될 실제 메모리의 주소값을 물리 메모리(physical memory) 라고 함.

* 이러한 변환 방식을 페이징(paging), 변환이 되는 최소의 메모리 단위를 페이지(page) 라고 함. 페이지의 크기는 대부분의 경우 1 페이지는 4 KB 정도임.

* 어떻게 변환을 수행할 지 기록한 테이블을 페이지 테이블(page table)이라고 함. 이 페이지 테이블은 각 프로그램 마다 하나씩 가지고 있음. 따라서 이 덕분에 따라서 구글 크롬에서의 0x1234 와 그림판의 0x1234 가 실제로는 다른 물리 메모리 주소를 참조할 수 있음.

* 우리가 흔히 사용하는 메모리의 크기는 8 기가 혹은 16 기가 바이트를 주로 사용. 페이징 덕분에 가상 메모리 공간 그 어디에 기록을 해도 페이지 테이블을 통해 현재 내가 사용 가능한 크기 이내의 물리 주소로 변환을 하게 되면 문제 없이 사용 가능

* 경우에 따라선, 메모리의 올라가 있는 전체 프로그램이 필요로 하는 메모리가 지금 내가 가지고 있는 물리 메모리의 용량 보다도 더 큰 경우도 해결 가능. 안쓰는 페이지 부터 하드 디스크에 복사해 놓고, 해당 페이지를 메모리를 필요로 하는 프로그램에 제공을 하는 방법.

* 만약에 하드 디스크에 복사해놓은 페이지를 다시 필요로 한다면, 그 때 운영체제가 해당 페이지를 다시 메모리에 복사해주면 됨. 메모리가 제한된 환경에서는 이와 같은 상황이 빈번하게 일어났음. 옛날 컴퓨터에서 프로그램을 실행했을 때 종종 매우 느려졌던 이유가 바로 물리 메모리가 부족해서 하드 디스크에 복사해 놓은 페이지를 읽어오느라 매우 느렸던 것. (메모리에 비해 하드 디스크는 매우 느림)

* 페이징으로 각 프로그램들은 메모리에 같이 올라가 있는 다른 프로그램들을 전혀 고려할 필요 없이 마치 자기 혼자서 메모리 전 공간을 사용하는 것 마냥 생각할 수 있음.

#### 정리

* 모든 연산은 CPU 에서 수행된다. 정확히 말하자면, CPU 의 자그마한 레지스터 상에서 수행된다. 64 비트 CPU 의 경우 레지스터의 크기는 8 바이트 이다.

* CPU 는 무슨 연산을 할 지 알려주는 명령어와, 명령어를 실행하기 위해 필요로 하는 데이터를 메모리 (램) 에서 읽는다.

* 프로그램을 실행한다는 것은 하드 디스크에 잠들어 있는 명령어들과 데이터를 메모리에 쓰는 것이라 생각하면 된다. 그리고 운영체제가 CPU 에 처음으로 실행해야 할 명령어의 주소값을 전달함으로써 프로그램이 시작된다.

* CPU 에는 캐시가 있어서 메모리 접근 횟수를 줄일 수 있다.

* 각 프로그램들은 마치 자신이 방대한 메모리 공간 전체를 사용하는 것 처럼 생각하며 작동한다.

* CPU 에서 참조하는 주소값은 실제 물리 메모리 주소값이 아니라 가상 메모리 주소값이다.

* 가상 메모리 주소값은 각 프로그램의 페이지 테이블을 통해서 실제 메모리 주소값으로 변환된다.

---

### 1. C언어를 배우는 이유

* 컴퓨터의 내부 원리를 알 수 있음
* 다른 언어를 익히기 쉬움
* 배울 내용이 적음

#### 컴파일러

* 컴파일 : 프로그래밍 언어를 컴퓨터가 이해할 수 있도록 기계어로 바꾸어 주는 역할을 수행하는 것

---

### 2. 코드 분석
```c
#include <stdio.h>
int main() {
  printf("Hello, World! \n");
  return 0;
}
```
* int : 정수(integer)
* main : 함수
* int main : 정수형을 반환하는 메인 함수
* printf : 콘솔 창에 내용을 출력하는 함수
* stdio.h : 표준 입출력 헤더(STandard Input Output header), 입출력을 관장하는 파일을 포함하고 있다.
* return 0 : 0을 운영체제(프로그램을 호출한 프로그램)한테 반환
* 주석 : 코드에 대한 부연 설명, 여러 줄에 걸칠 수 있는 `/* */`와 한줄만 적용되는 `//`가 있다.

#### 기수법

* 수(Number) : 물질의 양을 나타내는 단위
* 숫자(Digit) : 수를 기록할 수 있도록 시각화한 것

* 밑과 지수 : 아래의 수는 밑, 제곱을 나타낸 수는 지수
* (n)의 0제곱은 항상 1이다.

* 253
* 10진법은 자리수가 늘어날 때 마다 그것을 나타나는 숫자에 10이 곱해진다
* 2진법도 마찬가지로 자리수가 늘어날 때마다 2가 곱해진다.
    - 23 = 16 + 4 + 2 + 1 = 10111 (16, 8, 4, 2, 1)
    - 49 = 32 + 16 + 1 = 110001 (32, 16, 8, 4, 2, 1)
* 2진수를 10진수로 : 자리수가 올라갈 때 마다 자리수의 값이 두 배가 된다.
* 10진수를 2진수로 : 10진수를 2로 나누어서 나온 나머지를 몫이 0이 될 때까지 구하고 나머지들만 역순으로 배치하면 된다.

* 이진수는 값이 크기에 프로그래머들은 보통 16진법을 사용.
* 16진법은 숫자가 16개나 필요, 9 다음의 6개의 숫자를 알파벳을 이용해 표현
* 10 : A, 11 : B, 12 : C... 15 : F 방식으로 표현
* 16진수도 한 자리가 늘어날 때마다 16을 곱하면 됨
    - 123 = 7 * 16 + 11 = 0x7B(0x는 16진수임을 의미)
    - 19 = 16 + 3 = 0x13
    - 16782 = 4 * 4096(16의 세제곱) + 1 * 256(16의 두제곱) + 8 * 16 + 14 * 1(16의 0제곱) = 0x418E
* 16진수를 2진수로 : 16진수의 각 자리수를 (맨 앞자리를 제외하고는 반드시) 4자리 이진수로 변환해주면 됨
    - 4F38E = 100/1111/0011/1000/1110
* 2진수를 16진수로 : 2진수를 뒤에서부터 4자리를 끊어 읽으면 됨.
    - 4F38E 100/0001/1000/1110 : 0x418E

#### 메모리의 단위

* 휘발성 메모리 : 컴퓨터를 종료하면 데이터가 날아감, RAM(Random Access Memory)
* 비휘발성 메모리 : 데이터가 날아가지 않음, ROM(Read Only Memory)이나 하드디스크
* RAM는 데이터에 랜덤하게 접근할 수 있어서 속도가 빠름
* 이러한 특성 때문에 대부분 컴퓨터의 데이터는 메모리에 보관되어 있으며 틈틈히 중요한 데이터들은 하드 디스크에 저장함
* 컴퓨터의 한 개의 메모리 소자는 0 혹은 1 의 값을 보관할 수 있다. 이 이진수 한 자리를 가리켜 비트(Bit) 라고 부른다. 
* 1 개의 비트는 0 또는 1 의 값을 보관할 수 있다. 
* 너무나 작은 양이기에 8개의 비트를 묶어서 바이트(Byte) 라고 부른다. 8 비트 = 1 바이트
* 8 비트로 나타낼 수 있는 수, 다시말해 8 자리 이진수로 나타낼 수 있는 최대의 수
    - 00000000 ~ 11111111 = 0 ~ 255 = 0 ~ 0xFF

* 컴퓨터에서 연산을 담당하는 CPU의 메모리 공간인 레지스터(register), CPU에서 연산을 수행하기 위해 잠시 이곳에다가 값을 불러다 놓는다.
* 워드(Word) : 레지스터의 크기이자 컴퓨터 상에서 연산이 실행되는 최소 단위
* 32비트 컴퓨터의 경우 1 워드 = 32 비트 = 4 바이트, 64비트 컴퓨터의 경우 1 워드 = 64 비트 = 8 바이트

#### 정리

* 이진법은 0 과 1 로, 십진법은 0 부터 9로, 16진법은 0 부터 9, A, B, C, D, E, F 로 수를 표현. 
* 1비트는 이진수로 숫자 1 개를 의미하며, 1 바이트는 8 비트, 즉 이진수로 8 자리 수를 의미. 
* 1 바이트로 0 부터 255 까지의 수를 표현 가능. 컴퓨터에서 데이터를 잠시 기록해 놓는 것이 바로 메모리(RAM). 
* 보통의 컴퓨터의 경우 대부분 4 바이트 혹은 8 바이트 단위로 데이터를 처리.

---

### 3. 변수

* 컴퓨터가 기억하는 정보라는 것은 메모리에 전기 신호를 써놓는 것을 의미.
* 컴퓨터의 메모리인 RAM이라는 특별한 기억공간에 이를 기록.
* 철도처럼 직사각형이 붙어있는 형태로 표시, 각 방(사각형)에 1 바이트만큼의 데이터들을 저장 가능.
* 각방에 단순한 숫자로 이름을 붙임. 32 비트 CPU 기준 2의 32승(42억)개의 방을 가짐.
* 32비트 숫자를 매번 쓰는 대신 대개 16진법으로 주소값을 나타냄.
* 매번 16진수의 주소값을 사용하는 대신 변수에 주소값을 지정해서 변수를 호출해서 사용.
* 변수를 저장하면 컴퓨터는 알아서 메모리 어딘가에 해당 변수를 할당하고 내용을 저장.

```c
#include <stdio.h>
int main() {
  int a;
  a = 10;
  printf("a 의 값은 : %d \n", a);
  return 0;
}
```
* 변수 : 바뀔 수 있는 어떤 값을 보관하는 곳
* int : 변수의 자료형이 int(정수)형이라고 선언, -2147483648 에서 부터 2147483647 까지의 정수를 보관 가능
* %d : "" 다음에 처음으로 오는 변수(인자)를 10진수로 출력.
* %o : 인자의 값을 8진수로 출력
* %x : 인자의 값을 16진수로 출력

```c
#include <stdio.h>
int main() {
  float a = 3.141592f;
  double b = 3.141592;
  printf("a : %f \n", a);
  printf("b : %f \n", b);
  return 0;
}
```
* float : 실수형을 담을 수 있는 변수, double로 인식받지 않게 선언할 때 값 뒤에 f를 붙여야 한다.
* double : 실수형을 담을 수 있는 변수.
* %f : 실수형 변수를 출력하는 형식, 소수점 뒤의 값이 없더라도 소수점을 붙여야 한다.

```c
#include <stdio.h>
int main() {
  float a = 3.141592f;
  double b = 3.141592;
  int c = 123;
  printf("a : %.2f \n", a);
  printf("c : %5d \n", c);
  printf("b : %6.3f \n", b);
  return 0;
}
```
* %.(n)f : 소수점 n째 자리까지 무조건 표시.
* %(n)d : 자릿수를 n자리로 가능한한 표시.
* %(n).(N)f : 전체 자릿수는 n자리로 맞추되 반드시 소수점 N째 자리까지만 표시

#### C언어 변수 작명법

* 숫자는 중간이나 뒤에만 가능
* 영어, 숫자, _로만 구성
* 띄어쓰기 불가
* C 언어 예약어 불가

#### 정리

변수는 데이터를 임시로 저장하는 곳이며 자유롭게 쓰고 지울 수 있습니다.

각 변수에는 형(type) 이 있어서 해당 형에 맞는 데이터를 보관할 수 있습니다.

변수의 형으로는 정수값을 보관하는 char, int 등이 있고, 실수값을 보관하는 float 과 double 이 있습니다. 각각의 형들은 저장하는 데이터의 크기가 다릅니다.

int a = 10; 의 문장의 의미는 a 라는 정수형 변수를 정의한 뒤에, 해당 변수에 10 의 값을 대입한다 라는 뜻입니다.

변수의 이름을 정하기 위해서는 여러가지 규칙이 있습니다. 이 규칙에 알맞게 변수의 이름을 정해야 되며 그렇지 않을 경우 컴파일 오류가 발생합니다.

---

### 4. 연산자

#### 산술 연산자

* 사칙연산 가능
* /는 몫, %는 나머지를 의미

* 정수형 변수끼리 나누면 실제값이 실수라도 언제나 정수로 유지된다.
* 정수형 변수와 실수형 변수를 연산하면 실수형으로 출력 가능.
* 컴파일러의 산술 변환 : 자료형이 다른 두 변수를 연산 할 때 숫자의 범위가 큰 자료형으로 자료형이 바뀐다.


#### 대입 연산자

* 우측의 값을 좌측에 대입
* `a = a + 3` 같은 수학적으로 불가능한 식도 우측의 값을 먼저 계산하는 C언어에서는 가능.

```c
/* 대입 연산 */
#include <stdio.h>
int main() {
  int a = 1;

  printf("++a : %d \n", ++a);

  a = 1;
  printf("a++ : %d \n", a++);
  printf("a : %d \n", a);

  return 0;
}
```
* a++, ++a 는 각각 전위형, 후위형으로 미세한 차이가 있다.
* 전위형은 먼저 1을 더한 후 결과를 돌려주고, 후회형은 그 반대이다.

#### 비트 연산자

```c
/* 비트 연산 */
#include <stdio.h>
int main() {
  int a = 0xAF;  // 10101111
  int b = 0xB5;  // 10110101

  printf("%x \n", a & b);   // a & b = 10100101
  printf("%x \n", a | b);   // a | b =10111111
  printf("%x \n", a ^ b);   // a ^ b = 00011010
  printf("%x \n", ~a);      // ~a = 1....1 01010000
  printf("%x \n", a << 2);  // a << 2 = 1010111100
  printf("%x \n", b >> 3);  // b >> 3 = 00010110

  return 0;
}
```

* 비트 하나 하나에 대한 연산.
* 보통 8개의 비트를 묶어 1 바이트라 하고, 이진법으로 8자리 수, 십진법으로 0부터 255까지 나타날 수 있다.

* AND(&) 연산
    - 둘다 1이면 1, 하나라도 0이면 0으로 계산

* OR(|) 연산
    - 하나라도 1이면 1

* XOR(^) 연산
    - 두 수가 달라야만 1
   
* 반전 연산(~)
    - 0은 1로, 1은 0으로

* << 연산(쉬프트)
    - 왼쪽으로 비트를 쉬프트, 맨 앞의 숫자가 자리가 없으면 버려지고 새로 채워지는 숫자는 무조건 0

* >> 연산
    - 오른쪽으로 비트를 쉬프트, 숫자가 갈 자리가 없으면 앞부분에 맨 왼쪽에 있던 수를 복사

* int 형 변수는 하나의 데이터를 저장하기 위해 메모리 상의 4 바이트 (32비트)를 사용.
* 하나의 int 형 변수는 32자리의 이진수
    - int a = 1 == a = 00000000 00000000 00000000 00000001
    - int a = 0xAF == a = 10101111 == 00000000 00000000 00000000 10101111
        - 이를 반전시키면 11111111 11111111 11111111 01010000 == 0xFFFFFF50이 되는 것
    - <<와 >>도 똑같은 개념

#### 연산의 우선순위

* 1순위는 괄호
* 대부분 왼쪽 우선이지만 대입 연산자를 포함한 몇몇은 오른쪽 우선

#### 보수 표현법

* 변수의 타입에 따라 보관할 수 있는 데이터의 크기가 정해져 있다.

```c
#include <stdio.h>

int main() {
  int a = 2147483647;
  printf("a : %d \n", a);

  a++;
  printf("a : %d \n", a);

  return 0;
}
```

* 정수와 음수를 구분하는 방법
    - 1비트를 사용해서 부호를 나타낸다.
        - 첫번째 비트를 부호 비트로, 나머지는 실제 정수 데이터로 사용한다.
        - 0000과 1000을 모두 0으로 판단할 수 있는 문제가 생긴다.
    - 2의 보수 표현을 이용한다.
        - 컴퓨터가 4비트만 기억한다고 가정, x - x = 0이 나와야 함.
        - 이진수로 7인 0111에 더해 0000이 되는 이진수는 1001, 10000이 될 때 맨 앞의 1은 버려지기 때문
        - 이진수를 반전시킨 것에 1을 더하면 부호를 바꿀 수 있다.
        - 0000의 2의 보수는 그대로 0000이다.
        - int는 4바이트기에 최대 32비트, 32자리의 이진수까지 표현 가능, 십진법으로 나타내면 2,147,483,647까지 나타낼 수 있다. (unsigned 시 4294967295)
        - 맨 앞 비트를 부호 비트라고 생각하면 된다.
            - 음수나 양수의 덧셈 시 부호를 고려하지 않고 수행할 수 있다.
            - 맨 앞 비트를 사용해 부호를 빠르게 알아낼 수 있다.
    * 다시 위의 경우로 돌아가면 0x7FFFFFFF의 값을 1 증가시켜 0x800000000이 되고 이를 2의 보수 표현법으로 해석해 반전해서 1을 더하면 음수가 되버린다.
    * 오버플로우 : 자료형의 최대 범위보다 큰 수를 대입해 발생하는 문제

* unsigned int의 경우 0부터 4294967295까지의 수를 표현할 수 있다.
* unsigned int도 오버플로우가 발생할 수 있다. 음수 대신 0으로 돌아간다.

### 5. 문자 입력

* 0과 1밖에 처리하지 못하는 컴퓨터는 문자를 그대로 읽을 수 없기에 문자를 숫자에 대응시켜야 함.
* char : 1바이트 = 8비트, -128부터 127까지 숫자 표현 가능

```c
/* 문자를 저장하는 변수  */
#include <stdio.h>
int main() {
  char a;
  a = 'a';

  printf("a 의 값과 들어 있는 문자는? 값 : %d , 문자 : %c \n", a, a);
  return 0;
}
```

* 무조건 작은 따옴표로만 문자를 넣어야 함.
* 문자를 %d로 출력하면 해당 문자와 대응하는 유니코드가 출력됨.
* 유니코드의 전신인 아스키코드(ASCII, American Standard Code for Information Interchange)는 각각의 문자(알파벳)에 대응하는 번호를 붙인 것으로 0부터 127까지 총 128개(이후 1비트를 추가해서 256개)가 존재했음.
* 컴퓨터가 전세계로 보급되며 다양한 문자를 표현할 필요를 느끼자 유니코드(Unicode)라는 새로운 형식의 문자 체계를 도입. 한문자를 최대 4바이트(32비트)까지 처리. 

```c
/* 섭씨온도를 화씨로 바꾸기  */
#include <stdio.h>
int main() {
  double celsius;  // 섭씨 온도

  printf("섭씨 온도를 화씨 온도로 바꿔주는 프로그램 입니다. \n");
  printf("섭씨 온도를 입력해 주세요 : ");
  scanf_s("%lf", &celsius);  // 섭씨 온도를 입력 받는다.

  printf("섭씨 %f 도는 화씨로 %f 도 입니다 \n", celsius, 9 * celsius / 5 + 32);

  return 0;
}
```

* scanf : 화면(키보드)으로부터 결과를 받는 입력함수.
* printf 처럼 변수의 타입마다 입력받는 포맷을 달리 해야한다.
* printf와는 다르게 float는 %f로, double은 %lf로 입력받아야 한다.
* char : 최대 1바이트를 차지, 주로 문자를 저장하는데 사용, 한글은 2 바이트 이상을 차지하기에 한글을 넣으면 오류가 남.

```c
    //응용//
	int money;
	float money_USA = 1105.54;
	
	
	printf("얼마나 환전하시겠습니까?");
	scanf("%d", &money);

	printf("%d원을 환전한 금액은 %.2f 달러입니다.", money, money / money_USA);
	
	return 0;
```
